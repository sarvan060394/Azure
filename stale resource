def is_non_prod_namespace(namespace: str) -> bool:
    return "prod" not in namespace.lower()
def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version='v1', kind='Pod')

    stale_pods = []

    for ns in namespaces:
        if not is_non_prod_namespace(ns):
            logger.warning(f"Skipping namespace '{ns}' as it is considered prod.")
            continue
        try:
            pod_list = pods.get(namespace=ns)
            for pod in pod_list.items:
                container_statuses = pod.status.containerStatuses or []
                for cs in container_statuses:
                    if cs.state.waiting and cs.state.waiting.reason in statuses:
                        stale_pods.append({
                            "namespace": ns,
                            "name": pod.metadata.name,
                            "status": cs.state.waiting.reason
                        })
        except Exception as e:
            logger.error(f"Error retrieving pods from namespace {ns}: {e}")
    return stale_pods
def remove_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    stale_pods = list_stale_pods(k8s_client, namespaces, statuses)
    dyn_client = DynamicClient(k8s_client)
    deleted_pods = []

    for pod in stale_pods:
        try:
            dyn_client.resources.get(api_version="v1", kind="Pod").delete(
                namespace=pod["namespace"], name=pod["name"]
            )
            logger.info(f"Deleted pod {pod['name']} from namespace {pod['namespace']}")
            deleted_pods.append(pod)
        except Exception as e:
            logger.error(f"Error removing pod {pod['name']}: {e}")

    return {"deleted_pods": deleted_pods}
from fastapi import Query
from typing import Optional

DEFAULT_NON_PROD_NAMESPACES = ["dev", "qa", "test", "sandbox"]

@app.post("/delete-stale-pods")
def delete_stale_pods_endpoint(
    statuses: List[str] = Query(["CrashLoopBackOff", "Completed"]),
    namespaces: Optional[List[str]] = Query(None)
):
    used_namespaces = namespaces if namespaces else DEFAULT_NON_PROD_NAMESPACES
    return remove_stale_pods(k8s_client, used_namespaces, statuses)


;;;;;;;;;;;;;;;;;;;:::::

@app.post("/delete-stale-pods")
def delete_stale_pods_endpoint(
    openshift_cluster_url: str,
    username: str,
    password: str,
    statuses: List[str] = Query(["CrashLoopBackOff", "Completed"]),
    namespaces: Optional[List[str]] = Query(None)
):
    """
    API to delete stale pods based on user-selected statuses.
    """
    k8s_client = get_openshift_client(openshift_cluster_url, username, password)

    if namespaces is None:
        dyn_client = DynamicClient(k8s_client)
        all_projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project").get()
        namespaces = [
            project.metadata.name
            for project in all_projects.items
            if is_non_prod_namespace(k8s_client, project.metadata.name)
        ]
    
    return remove_stale_pods(k8s_client, namespaces, statuses)

def remove_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    stale_pods = list_stale_pods(k8s_client, namespaces, statuses)
    dyn_client = DynamicClient(k8s_client)
    deleted_pods = []

    for pod in stale_pods:
        try:
            dyn_client.resources.get(api_version="v1", kind="Pod").delete(
                namespace=pod["namespace"], name=pod["name"]
            )
            logger.info(f"Deleted pod {pod['name']} from namespace {pod['namespace']}")
            deleted_pods.append(pod)
        except Exception as e:
            logger.error(f"Error removing pod {pod['name']}: {e}")

    return {"deleted_pods": deleted_pods}


def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version="v1", kind="Pod")

    stale_pods = []

    for ns in namespaces:
        if not is_non_prod_namespace(k8s_client, ns):
            continue  # Skip prod namespaces
        
        try:
            pod_list = pods.get(namespace=ns)
            for pod in pod_list.items:
                container_statuses = pod.status.containerStatuses or []
                for cs in container_statuses:
                    if cs.state.waiting and cs.state.waiting.reason in statuses:
                        stale_pods.append({
                            "namespace": ns,
                            "name": pod.metadata.name,
                            "status": cs.state.waiting.reason
                        })
        except Exception as e:
            logger.error(f"Error retrieving pods from namespace {ns}: {e}")
    
    return stale_pods

def is_non_prod_namespace(k8s_client, namespace: str) -> bool:
    """
    Checks if a namespace is labeled as non-prod in OpenShift.
    """
    dyn_client = DynamicClient(k8s_client)
    projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project")

    try:
        project = projects.get(name=namespace)
        env_type = project.metadata.labels.get("env_type", "").lower()
        if env_type == "nonprod":
            return True
        logger.warning(f"Namespace {namespace} is labeled as '{env_type}', skipping deletion.")
    except Exception as e:
        logger.error(f"Error retrieving namespace metadata for {namespace}: {e}")

    return False


--------------------*********************-----------------------------------


def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    dyn_client = DynamicClient(k8s_client)
    v1_pods = dyn_client.resources.get(api_version="v1", kind="Pod")
    stale_pods = {}

    for ns in namespaces:
        try:
            pods = v1_pods.get(namespace=ns)
        except Exception as e:
            logger.error(f"Failed to fetch pods in namespace '{ns}': {str(e)}")
            continue

        for pod in pods.items:
            pod_name = pod.metadata.name
            pod_status = pod.status.phase
            container_statuses = pod.status.containerStatuses or []
            deletion_timestamp = pod.metadata.deletionTimestamp

            is_crashloop = any(
                cs.state.waiting and cs.state.waiting.reason == "CrashLoopBackOff"
                for cs in container_statuses
            )
            is_error = any(
                cs.state.waiting and cs.state.waiting.reason == "Error"
                for cs in container_statuses
            )
            is_pending = pod_status == "Pending"
            is_completed = pod_status == "Succeeded" and "Completed" in statuses
            is_terminating = deletion_timestamp is not None

            match = (
                ("CrashLoopBackOff" in statuses and is_crashloop) or
                ("Error" in statuses and is_error) or
                ("Pending" in statuses and is_pending) or
                ("Completed" in statuses and is_completed) or
                ("Terminating" in statuses and is_terminating)
            )

            if match:
                stale_pods.setdefault(ns, []).append(pod_name)
                logger.info(f"Identified stale pod '{pod_name}' with status '{pod_status}' in namespace '{ns}'")

    return stale_pods

from pydantic import BaseModel
from typing import List, Optional

class DeletePodRequest(BaseModel):
    openshift_cluster_url: str
    username: str
    password: str
    namespaces: Optional[List[str]] = []  # default namespaces to search
    statuses: List[str] = ["CrashLoopBackOff", "Completed"]  # default selected


def validate_namespaces_are_nonprod(k8s_client, namespaces: List[str]) -> List[str]:
    dyn_client = DynamicClient(k8s_client)
    v1_projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project")
    valid_namespaces = []

    for ns in namespaces:
        try:
            project = v1_projects.get(name=ns)
            labels = project.metadata.labels or {}
            if labels.get("env_type") == "nonprod":
                valid_namespaces.append(ns)
            else:
                logger.warning(f"Namespace '{ns}' is labeled as PROD or not labeled at all. Skipping.")
        except Exception as e:
            logger.error(f"Error validating namespace '{ns}': {str(e)}")

    return valid_namespaces
-------(((------

from fastapi import APIRouter
from pydantic import BaseModel
from typing import List, Optional
import logging

router = APIRouter()
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")

class DeletePodsRequest(BaseModel):
    openshift_cluster_url: str
    username: str
    password: str
    namespaces: Optional[List[str]] = []
    statuses: List[str]

@router.post("/delete-stale-pods")
def delete_stale_pods(req: DeletePodsRequest):
    logger.info("Starting stale pod deletion request")

    try:
        k8s_client = get_openshift_client(req.openshift_cluster_url, req.username, req.password)
        logger.info("OpenShift client initialized")
    except Exception as e:
        logger.error(f"Failed to authenticate OpenShift client: {str(e)}")
        return {"error": str(e)}

    try:
        validated_namespaces = validate_namespaces_are_nonprod(k8s_client, req.namespaces)
        if not validated_namespaces:
            logger.warning("No nonprod namespaces found in request. Exiting.")
            return {"message": "No nonprod namespaces available for processing"}
    except Exception as e:
        logger.error(f"Namespace validation failed: {str(e)}")
        return {"error": str(e)}

    try:
        result = remove_stale_pods(k8s_client, validated_namespaces, req.statuses)
        logger.info("Stale pod deletion process completed")
        return result
    except Exception as e:
        logger.error(f"Stale pod deletion failed: {str(e)}")
        return {"error": str(e)}

def remove_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    stale_pods = list_stale_pods(k8s_client, namespaces, statuses)
    dyn_client = DynamicClient(k8s_client)
    v1_pods = dyn_client.resources.get(api_version="v1", kind="Pod")

    for ns, pods in stale_pods.items():
        for pod_name in pods:
            try:
                v1_pods.delete(name=pod_name, namespace=ns)
                logger.info(f"Deleted pod '{pod_name}' in namespace '{ns}'")
            except Exception as e:
                logger.error(f"Error deleting pod '{pod_name}' in namespace '{ns}': {str(e)}")

    return {"deleted_pods": stale_pods}



def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]) -> Dict[str, List[str]]:
    dyn_client = DynamicClient(k8s_client)
    v1_pods = dyn_client.resources.get(api_version="v1", kind="Pod")
    stale_pods = {}

    for ns in namespaces:
        try:
            pods = v1_pods.get(namespace=ns)
        except Exception as e:
            logger.error(f"Failed to fetch pods in namespace '{ns}': {str(e)}")
            continue

        for pod in pods.items:
            pod_name = pod.metadata.name
            pod_status = pod.status.phase
            container_statuses = pod.status.containerStatuses or []
            deletion_timestamp = pod.metadata.deletionTimestamp

            is_crashloop = any(
                cs.state.waiting and cs.state.waiting.reason == "CrashLoopBackOff"
                for cs in container_statuses
            )
            is_error = any(
                cs.state.waiting and cs.state.waiting.reason == "Error"
                for cs in container_statuses
            )
            is_pending = pod_status == "Pending"
            is_completed = pod_status == "Succeeded"
            is_terminating = deletion_timestamp is not None

            match = (
                ("CrashLoopBackOff" in statuses and is_crashloop) or
                ("Error" in statuses and is_error) or
                ("Pending" in statuses and is_pending) or
                ("Completed" in statuses and is_completed) or
                ("Terminating" in statuses and is_terminating)
            )

            if match:
                stale_pods.setdefault(ns, []).append(pod_name)
                logger.info(f"Identified stale pod '{pod_name}' in namespace '{ns}'")

    return stale_pods


from openshift.dynamic import DynamicClient

def validate_namespaces_are_nonprod(k8s_client, namespaces: List[str]) -> List[str]:
    dyn_client = DynamicClient(k8s_client)
    v1_projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project")
    valid_namespaces = []

    for ns in namespaces:
        try:
            project = v1_projects.get(name=ns)
            labels = project.metadata.labels or {}
            if labels.get("env_type") == "nonprod":
                valid_namespaces.append(ns)
            else:
                logger.warning(f"Namespace '{ns}' is not nonprod. Skipping.")
        except Exception as e:
            logger.error(f"Failed to validate namespace '{ns}': {str(e)}")

    return valid_namespaces

------""""------


import logging
from fastapi import FastAPI, Query, HTTPException
from typing import List, Optional
from kubernetes.dynamic import DynamicClient
from kubernetes.client import Configuration

# Configure logger
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.post("/delete-stale-pods")
def delete_stale_pods_endpoint(
    openshift_cluster_url: str,
    username: str,
    password: str,
    statuses: List[str] = Query(["CrashLoopBackOff", "Completed"]),
    namespaces: Optional[List[str]] = Query(None)
):
    """
    API to delete stale pods based on user-selected statuses.
    """
    logger.info(f"Started deleting stale pods for statuses {statuses} and namespaces {namespaces}")

    try:
        k8s_client = get_openshift_client(openshift_cluster_url, username, password)
    except Exception as e:
        logger.error(f"Error initializing OpenShift client: {e}")
        raise HTTPException(status_code=500, detail="Failed to authenticate with OpenShift cluster")

    if namespaces is None:
        logger.info("No namespaces provided, listing non-prod namespaces.")
        try:
            dyn_client = DynamicClient(k8s_client)
            all_projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project").get()
            namespaces = [
                project.metadata.name
                for project in all_projects.items
                if is_non_prod_namespace(k8s_client, project.metadata.name)
            ]
            logger.info(f"Found namespaces: {namespaces}")
        except Exception as e:
            logger.error(f"Error retrieving namespaces: {e}")
            raise HTTPException(status_code=500, detail="Failed to retrieve namespaces")

    try:
        result = remove_stale_pods(k8s_client, namespaces, statuses)
        logger.info(f"Completed stale pod deletion. Deleted pods: {result['deleted_pods']}")
        return result
    except Exception as e:
        logger.error(f"Error in removing stale pods: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete stale pods")

def remove_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    logger.info(f"Started removing stale pods from namespaces {namespaces} for statuses {statuses}")

    stale_pods = list_stale_pods(k8s_client, namespaces, statuses)
    dyn_client = DynamicClient(k8s_client)
    deleted_pods = []

    for pod in stale_pods:
        try:
            logger.info(f"Attempting to delete pod {pod['name']} from namespace {pod['namespace']}")
            dyn_client.resources.get(api_version="v1", kind="Pod").delete(
                namespace=pod["namespace"], name=pod["name"]
            )
            logger.info(f"Successfully deleted pod {pod['name']} from namespace {pod['namespace']}")
            deleted_pods.append(pod)
        except Exception as e:
            logger.error(f"Error removing pod {pod['name']} from namespace {pod['namespace']}: {e}")

    logger.info(f"Finished removing stale pods. Total deleted: {len(deleted_pods)}")
    return {"deleted_pods": deleted_pods}

def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    logger.info(f"Listing stale pods from namespaces {namespaces} with statuses {statuses}")

    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version="v1", kind="Pod")

    stale_pods = []

    for ns in namespaces:
        if not is_non_prod_namespace(k8s_client, ns):
            logger.info(f"Skipping prod namespace {ns}")
            continue  # Skip prod namespaces

        try:
            pod_list = pods.get(namespace=ns)
            for pod in pod_list.items:
                container_statuses = pod.status.containerStatuses or []
                for cs in container_statuses:
                    if cs.state.waiting and cs.state.waiting.reason in statuses:
                        stale_pods.append({
                            "namespace": ns,
                            "name": pod.metadata.name,
                            "status": cs.state.waiting.reason
                        })
        except Exception as e:
            logger.error(f"Error retrieving pods from namespace {ns}: {e}")

    logger.info(f"Finished listing stale pods. Total found: {len(stale_pods)}")
    return stale_pods

def is_non_prod_namespace(k8s_client, namespace: str) -> bool:
    """
    Checks if a namespace is labeled as non-prod in OpenShift.
    """
    logger.info(f"Checking if namespace {namespace} is non-prod")

    dyn_client = DynamicClient(k8s_client)
    projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project")

    try:
        project = projects.get(name=namespace)
        env_type = project.metadata.labels.get("env_type", "").lower()
        if env_type == "nonprod":
            logger.info(f"Namespace {namespace} is non-prod.")
            return True
        logger.warning(f"Namespace {namespace} is labeled as '{env_type}', skipping deletion.")
    except Exception as e:
        logger.error(f"Error retrieving namespace metadata for {namespace}: {e}")

    return False


from fastapi import FastAPI, Query, HTTPException, Form
from typing import List, Optional

@app.post("/delete-stale-pods")
def delete_stale_pods_endpoint(
    openshift_cluster_url: str = Form(..., description="The URL of the OpenShift cluster."),
    username: str = Form(..., description="The username to authenticate with OpenShift."),
    password: str = Form(..., description="The password to authenticate with OpenShift."),
    statuses: List[str] = Query(
        ["CrashLoopBackOff", "Completed"],
        description="The statuses of the pods to consider for deletion. You can select multiple statuses.",
        example=["CrashLoopBackOff", "Completed"]
    ),
    namespaces: Optional[List[str]] = Query(
        None,
        description="The namespaces to check for stale pods. You can select multiple namespaces. If not provided, it will default to non-prod namespaces.",
        example=["namespace1", "namespace2"]
    )
):
    """
    API to delete stale pods based on user-selected statuses and namespaces.
    """
    logger.info(f"Started deleting stale pods for statuses {statuses} and namespaces {namespaces}")

    try:
        k8s_client = get_openshift_client(openshift_cluster_url, username, password)
    except Exception as e:
        logger.error(f"Error initializing OpenShift client: {e}")
        raise HTTPException(status_code=500, detail="Failed to authenticate with OpenShift cluster")

    if namespaces is None:
        logger.info("No namespaces provided, listing non-prod namespaces.")
        try:
            dyn_client = DynamicClient(k8s_client)
            all_projects = dyn_client.resources.get(api_version="project.openshift.io/v1", kind="Project").get()
            namespaces = [
                project.metadata.name
                for project in all_projects.items
                if is_non_prod_namespace(k8s_client, project.metadata.name)
            ]
            logger.info(f"Found namespaces: {namespaces}")
        except Exception as e:
            logger.error(f"Error retrieving namespaces: {e}")
            raise HTTPException(status_code=500, detail="Failed to retrieve namespaces")

    try:
        result = remove_stale_pods(k8s_client, namespaces, statuses)
        logger.info(f"Completed stale pod deletion. Deleted pods: {result['deleted_pods']}")
        return result
    except Exception as e:
        logger.error(f"Error in removing stale pods: {e}")
        raise HTTPException(status_code=500, detail="Failed to delete stale pods")




----@@@@@-----


from typing import List, Optional
from datetime import datetime
from fastapi import Query
from openshift.dynamic import DynamicClient
import logging

# Logger setup
logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)

# Function to list stale pods based on status
def list_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    """
    List stale pods based on the user-defined statuses.

    Parameters:
    - k8s_client: OpenShift client to interact with the cluster.
    - namespaces: List of namespaces to search for stale pods.
    - statuses: List of statuses (e.g., 'CrashLoopBackOff', 'ImagePullBackOff') to identify stale pods.

    Returns:
    - A list of stale pods matching the specified statuses.
    """
    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version="v1", kind="Pod")

    stale_pods = []

    for ns in namespaces:
        try:
            pod_list = pods.get(namespace=ns)
            for pod in pod_list.items:
                container_statuses = pod.status.containerStatuses or []
                for cs in container_statuses:
                    if cs.state.waiting and cs.state.waiting.reason in statuses:
                        stale_pods.append({
                            "namespace": ns,
                            "name": pod.metadata.name,
                            "status": cs.state.waiting.reason,
                            "container_name": cs.name,
                            "created_at": pod.metadata.creationTimestamp
                        })
        except Exception as e:
            logger.error(f"Error retrieving pods from namespace {ns}: {e}")

    return stale_pods

# Function to remove stale pods and associated resources like ReplicaSet and DeploymentConfig
def remove_stale_pods(k8s_client, namespaces: List[str], statuses: List[str]):
    stale_pods = list_stale_pods(k8s_client, namespaces, statuses)
    dyn_client = DynamicClient(k8s_client)
    deleted_pods = []

    for pod in stale_pods:
        try:
            # Remove the pod
            dyn_client.resources.get(api_version="v1", kind="Pod").delete(
                namespace=pod["namespace"], name=pod["name"]
            )
            logger.info(f"Deleted pod {pod['name']} from namespace {pod['namespace']}")
            deleted_pods.append(pod)

            # Check if the pod is associated with a ReplicaSet or ReplicaController
            associated_rs = get_associated_replicaset(k8s_client, pod["namespace"], pod["name"])
            if associated_rs:
                delete_associated_replicaset(k8s_client, pod["namespace"], associated_rs)
                
            # Check if the ReplicaSet is associated with a DeploymentConfig or Deployment
            associated_dc = get_associated_deploymentconfig(k8s_client, pod["namespace"], associated_rs)
            if associated_dc:
                delete_associated_deploymentconfig(k8s_client, pod["namespace"], associated_dc)

        except Exception as e:
            logger.error(f"Error removing pod {pod['name']}: {e}")

    return {"deleted_pods": deleted_pods}

# Function to get associated ReplicaSet for a pod
def get_associated_replicaset(k8s_client, namespace: str, pod_name: str):
    dyn_client = DynamicClient(k8s_client)
    pods = dyn_client.resources.get(api_version="v1", kind="Pod")
    
    try:
        pod = pods.get(name=pod_name, namespace=namespace)
        for owner in pod.metadata.ownerReferences:
            if owner.kind == "ReplicaSet":
                return owner.name
    except Exception as e:
        logger.error(f"Error retrieving ReplicaSet for pod {pod_name}: {e}")
    return None

# Function to delete associated ReplicaSet
def delete_associated_replicaset(k8s_client, namespace: str, replicaset_name: str):
    dyn_client = DynamicClient(k8s_client)
    try:
        dyn_client.resources.get(api_version="apps/v1", kind="ReplicaSet").delete(
            namespace=namespace, name=replicaset_name
        )
        logger.info(f"Deleted ReplicaSet {replicaset_name} from namespace {namespace}")
    except Exception as e:
        logger.error(f"Error deleting ReplicaSet {replicaset_name}: {e}")

# Function to get associated DeploymentConfig for a ReplicaSet
def get_associated_deploymentconfig(k8s_client, namespace: str, replicaset_name: str):
    dyn_client = DynamicClient(k8s_client)
    deployments = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig")

    try:
        deployment_list = deployments.get(namespace=namespace)
        for deployment in deployment_list.items:
            for rs in deployment.spec.replicasets:
                if rs.name == replicaset_name:
                    return deployment.metadata.name
    except Exception as e:
        logger.error(f"Error retrieving DeploymentConfig for ReplicaSet {replicaset_name}: {e}")
    return None

# Function to delete associated DeploymentConfig
def delete_associated_deploymentconfig(k8s_client, namespace: str, deploymentconfig_name: str):
    dyn_client = DynamicClient(k8s_client)
    try:
        dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").delete(
            namespace=namespace, name=deploymentconfig_name
        )
        logger.info(f"Deleted DeploymentConfig {deploymentconfig_name} from namespace {namespace}")
    except Exception as e:
        logger.error(f"Error deleting DeploymentConfig {deploymentconfig_name}: {e}")

# Function to list stale images
def list_stale_images(k8s_client, image_pull_threshold: int = 30):
    """
    List stale images from the OpenShift registry or Artifactory.
    
    Parameters:
    - k8s_client: OpenShift client to interact with the cluster.
    - image_pull_threshold: Time in days since the image was last pulled to consider it stale.

    Returns:
    - A list of stale images.
    """
    dyn_client = DynamicClient(k8s_client)
    images = dyn_client.resources.get(api_version="image.openshift.io/v1", kind="ImageStream")
    
    stale_images = []

    try:
        # Get all image streams across namespaces
        image_stream_list = images.get()
        for image_stream in image_stream_list.items:
            for tag in image_stream.status.tags:
                image_tag = tag.get("tag")
                image_data = tag.get("items", [])
                if not image_data:
                    continue

                # Check if image has not been used recently
                for image in image_data:
                    image_pull_time = image.get("created", None)
                    if image_pull_time:
                        # Convert the 'created' timestamp to a datetime object
                        created_time = datetime.strptime(image_pull_time, "%Y-%m-%dT%H:%M:%SZ")
                        # Calculate the difference in days between current date and image creation date
                        days_since_pull = (datetime.utcnow() - created_time).days

                        if days_since_pull > image_pull_threshold:
                            stale_images.append({
                                "image_stream": image_stream.metadata.name,
                                "tag": image_tag,
                                "image_digest": image.imageDigest,
                                "created_at": created_time,
                                "days_since_pull": days_since_pull
                            })
                        
    except Exception as e:
        logger.error(f"Error listing stale images: {e}")

    return stale_images
