from fastapi import FastAPI, Query
from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

app = FastAPI()

# Map your OpenShift cluster names to kubeconfig file paths
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

@app.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of OpenShift cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


from fastapi import APIRouter, Query
from typing import List
from services.image_service import get_cluster_images

router = APIRouter()

@router.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    return get_cluster_images(cluster_names, namespaces)

-----------------------------------

from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

# Update this with your actual cluster name to kubeconfig file path
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return dynamic.DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

def get_cluster_images(cluster_names: List[str], namespaces: List[str]) -> Dict:
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response

----------------------**************** ecluding build and deploy pods *************--------------------------------

import re

exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

...

if exclude_pattern.match(pod_name):
    continue


import re

def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # --- Pods ---
    try:
        # Compile a regex to match pod names like: myapp-1-build, app-deploy-abc, etc.
        exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name

            if exclude_pattern.match(pod_name):
                continue  # Skip build/deploy pods

            for container in pod.spec.containers:
                record_usage(container.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    # return result after all processing
    result["all_images"] = sorted(result["all_images"])
    return result

---------- ******* scan **********-------------------------


from fastapi import APIRouter, Query
from services.image_service import get_images_across_clusters

router = APIRouter()

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com", description="Comma-separated OpenShift cluster URLs"),
    namespaces: str = Query("default", description="Comma-separated namespaces")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    return await get_images_across_clusters(cluster_list, namespace_list)

*******************************************************************

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    response = {}
    all_images = set()

    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                all_images.update(ns_data["all_images"])
                cluster_data[ns] = ns_data

            response[url] = cluster_data
        except Exception as e:
            response[url] = {"error": str(e)}

    # Get Aqua token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Fetch reports in parallel
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Analyze reports and build final structure
    vulnerable_images_with_fixes = []

    for cluster_data in response.values():
        for ns_data in cluster_data.values():
            image_usage = ns_data.get("image_usage", {})
            ns_data["vulnerabilities"] = {}

            for image in ns_data["all_images"]:
                report = image_report_map.get(image, {})
                ns_data["vulnerabilities"][image] = report

                if not report or "error" in report:
                    continue

                fixed_cves = []
                for cve in report.get("cves", []):
                    fix = cve.get("fix_version")
                    if fix:
                        fixed_cves.append({
                            "name": cve.get("name"),
                            "severity": cve.get("severity"),
                            "fix_version": fix,
                            "file": cve.get("file"),
                            "url": cve.get("url")
                        })

                if fixed_cves:
                    vulnerable_images_with_fixes.append({
                        "image": image,
                        "used_by": image_usage.get(image, {}),
                        "vulnerabilities": fixed_cves
                    })

    response["vulnerable_images_with_fixes"] = vulnerable_images_with_fixes
    return response


def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for deploy in deployments.items:
            for c in deploy.spec.template.spec.containers:
                record_usage(c.image, "Deployments", deploy.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name
            if exclude_pattern.match(pod_name):
                continue
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result
**********************************************************************************

import httpx

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    image_url = f"{AQUA_SCAN_URL}/{image.lstrip('/')}"
    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}


for cluster_data in response.values():
    if not isinstance(cluster_data, dict):
        continue
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue
        image_usage = ns_data.get("image_usage", {})


print("DEBUG ns_data =", ns_data, type(ns_data))


# Analyze reports and build final structure
vulnerable_images_with_fixes = []

for cluster_data in response.values():
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue

        image_usage = ns_data.get("image_usage", {})
        ns_data["vulnerabilities"] = {}

        for image in ns_data["all_images"]:
            report = image_report_map.get(image, {})
            ns_data["vulnerabilities"][image] = report

            if not report or "error" in report:
                continue

            fixed_cves = []
            for cve in report.get("cves", []):
                fix = cve.get("fix_version")
                if fix:
                    fixed_cves.append({
                        "name": cve.get("name"),
                        "severity": cve.get("severity"),
                        "fix_version": fix,
                        "file": cve.get("file"),
                        "url": cve.get("url")
                    })

            if fixed_cves:
                vulnerable_images_with_fixes.append({
                    "image": image,
                    "used_by": image_usage.get(image, {}),
                    "vulnerabilities": fixed_cves
                })

import httpx
from urllib.parse import urljoin

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

def rewrite_image_url_for_aqua(image: str) -> str:
    """
    Converts OpenShift image URL into Aqua-compatible path.
    From: registry-nonprod.sdi.crp.bnk.com/73717/imagename:tag
    To:   registry-nonprod/73717/imagename:tag
    """
    parts = image.split('/')
    if len(parts) >= 3:
        registry_full = parts[0]
        registry = registry_full.split('.')[0]  # only 'registry-nonprod'
        path = '/'.join(parts[1:])
        return f"{registry}/{path}"
    return image  # fallback as-is

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    aqua_image_path = rewrite_image_url_for_aqua(image)
    image_url = urljoin(AQUA_SCAN_URL + "/", aqua_image_path)

    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}

vulnerable_images = []
vulnerable_image_fixes = {}
resource_usage = {}

for cluster_data in response.values():
    if not isinstance(cluster_data, dict):
        continue

    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue

        image_usage = ns_data.get("image_usage", {})
        ns_data["vulnerabilities"] = {}

        for image in ns_data["all_images"]:
            report = image_report_map.get(image, {})
            ns_data["vulnerabilities"][image] = report

            if not report or "error" in report:
                continue

            fixed_cves = []
            for cve in report.get("cves", []):
                fix = cve.get("fix_version")
                if fix:
                    fixed_cves.append({
                        "name": cve.get("name"),
                        "severity": cve.get("severity"),
                        "fix_version": fix,
                        "file": cve.get("file"),
                        "url": cve.get("url")
                    })

            if fixed_cves:
                vulnerable_images.append(image)
                vulnerable_image_fixes[image] = fixed_cves
                resource_usage[image] = image_usage.get(image, {})

# Final structured response to user
return {
    "vulnerable_images": sorted(set(vulnerable_images)),
    "vulnerable_image_fixes": vulnerable_image_fixes,
    "resource_usage": resource_usage
}

*****************************************************

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    # Step 1: Collect all images and their usage across clusters and namespaces
    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                for image in ns_data["all_images"]:
                    all_images.add(image)
                    if image not in image_usage_map:
                        image_usage_map[image] = ns_data["image_usage"].get(image, {})
                    else:
                        # Merge usage if already exists
                        for key in ["Pods", "Deployments", "DeploymentConfigs"]:
                            image_usage_map[image].setdefault(key, [])
                            image_usage_map[image][key].extend(ns_data["image_usage"].get(image, {}).get(key, []))

        except Exception as e:
            skipped_images.append({
                "image": f"Cluster: {url}",
                "error": str(e)
            })

    # Step 2: Get Aqua Token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Step 3: Fetch reports in parallel
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Step 4: Process vulnerabilities
    vulnerable_images = []

    for image, report in image_report_map.items():
        if not report or "error" in report:
            skipped_images.append({
                "image": image,
                "error": report.get("error", "unknown error")
            })
            continue

        fixed_cves = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                fixed_cves.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if fixed_cves:
            vulnerable_images.append({
                "image": image,
                "fixes": fixed_cves,
                "used_by": image_usage_map.get(image, {})
            })

    return {
        "vulnerable_images": vulnerable_images,
        "skipped_images": skipped_images
    }

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    # Step 1: Collect all images and usage
    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                for image in ns_data["all_images"]:
                    all_images.add(image)
                    if image not in image_usage_map:
                        image_usage_map[image] = ns_data["image_usage"].get(image, {})
                    else:
                        for key in ["Pods", "Deployments", "DeploymentConfigs"]:
                            image_usage_map[image].setdefault(key, [])
                            image_usage_map[image][key].extend(
                                ns_data["image_usage"].get(image, {}).get(key, [])
                            )
        except Exception as e:
            skipped_images.append({
                "image": f"Cluster: {url}",
                "error": str(e)
            })

    # Step 2: Get Aqua Token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Step 3: Fetch Aqua scan reports
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Step 4: Build final return values
    vulnerable_images = []
    image_fixes = {}
    image_usage = {}
    
    for image, report in image_report_map.items():
        if not report or "error" in report:
            skipped_images.append({
                "image": image,
                "error": report.get("error", "unknown error")
            })
            continue

        fixed_cves = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                fixed_cves.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if fixed_cves:
            vulnerable_images.append(image)
            image_fixes[image] = fixed_cves
            image_usage[image] = image_usage_map.get(image, {})

    return {
        "vulnerable_images": vulnerable_images,
        "image_fixes": image_fixes,
        "image_usage": image_usage,
        "skipped_images": skipped_images
    }



---

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com"),
    namespaces: str = Query("default"),
    dg_email: str = Query(..., description="Distribution group email to send results")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    result = await get_images_across_clusters(cluster_list, namespace_list)

    # Send email with result
    await send_email_with_results(result, dg_email)

    return result
import smtplib
import json
from email.message import EmailMessage
import ssl
import os

SMTP_SERVER = os.getenv("SMTP_SERVER", "smtp.yourorg.com")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USERNAME = os.getenv("SMTP_USERNAME")
SMTP_PASSWORD = os.getenv("SMTP_PASSWORD")
FROM_EMAIL = os.getenv("FROM_EMAIL", SMTP_USERNAME)

async def send_email_with_results(result: dict, to_email: str):
    subject = "OpenShift Vulnerability Report"
    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = FROM_EMAIL
    message["To"] = to_email

    # Pretty JSON string as body
    result_summary = json.dumps({
        "vulnerable_images": result.get("vulnerable_images", []),
        "image_fixes": result.get("image_fixes", {}),
        "image_usage": result.get("image_usage", {}),
        "skipped_images": result.get("skipped_images", [])
    }, indent=2)

    message.set_content(f"""✅ OpenShift Vulnerability Report

{result_summary}
""")

    # Attach full JSON as file too
    message.add_attachment(
        result_summary.encode("utf-8"),
        maintype="application",
        subtype="json",
        filename="vulnerability_report.json"
    )

    try:
        context = ssl.create_default_context()
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.send_message(message)
            print(f"✅ Email sent to {to_email}")
    except Exception as e:
        print(f"❌ Failed to send email to {to_email}: {e}")



*********************************** with table ************************************


import smtplib
import json
from email.message import EmailMessage
from email.utils import make_msgid
import ssl
import os

SMTP_SERVER = os.getenv("SMTP_SERVER", "smtp.yourorg.com")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USERNAME = os.getenv("SMTP_USERNAME")
SMTP_PASSWORD = os.getenv("SMTP_PASSWORD")
FROM_EMAIL = os.getenv("FROM_EMAIL", SMTP_USERNAME)

def build_html_report(result: dict) -> str:
    vulnerable_images = result.get("vulnerable_images", [])
    image_fixes = result.get("image_fixes", {})
    image_usage = result.get("image_usage", {})
    skipped_images = result.get("skipped_images", [])

    html = """
    <html>
    <body>
    <h2>OpenShift Vulnerability Report</h2>
    <h3>Vulnerable Images</h3>
    <table border="1" cellpadding="6" cellspacing="0">
        <tr>
            <th>Image</th>
            <th>Fix Count</th>
            <th>Resources Using Image</th>
        </tr>
    """

    for image in vulnerable_images:
        fixes = image_fixes.get(image, [])
        usage = image_usage.get(image, {})
        usage_str = ", ".join(
            [f"{k}: {', '.join(v)}" for k, v in usage.items() if v]
        )
        html += f"""
        <tr>
            <td>{image}</td>
            <td>{len(fixes)}</td>
            <td>{usage_str}</td>
        </tr>
        """

    html += """
    </table>
    <br>
    <h3>Skipped Images</h3>
    <table border="1" cellpadding="6" cellspacing="0">
        <tr>
            <th>Image</th>
            <th>Error</th>
        </tr>
    """

    for entry in skipped_images:
        html += f"""
        <tr>
            <td>{entry.get("image")}</td>
            <td>{entry.get("error")}</td>
        </tr>
        """

    html += """
    </table>
    <br><p>Attached: Full vulnerability report (JSON)</p>
    </body>
    </html>
    """

    return html

async def send_email_with_results(result: dict, to_email: str):
    subject = "OpenShift Vulnerability Report"
    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = FROM_EMAIL
    message["To"] = to_email

    # Plaintext fallback
    message.set_content("Your OpenShift vulnerability report is attached.")

    # HTML table
    html_body = build_html_report(result)
    message.add_alternative(html_body, subtype="html")

    # JSON attachment
    json_data = json.dumps(result, indent=2)
    message.add_attachment(
        json_data.encode("utf-8"),
        maintype="application",
        subtype="json",
        filename="vulnerability_report.json"
    )

    try:
        context = ssl.create_default_context()
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.send_message(message)
            print(f"✅ Email sent to {to_email}")
    except Exception as e:
        print(f"❌ Failed to send email to {to_email}: {e}")


*******************************************************************************

from typing import Optional
from fastapi import APIRouter, Query
from services.image_service import get_images_across_clusters
from services.email_service import send_email_with_results

router = APIRouter()

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com"),
    namespaces: str = Query("default"),
    dg_email: Optional[str] = Query(None, description="Optional: DG email to send vulnerability report")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    
    result = await get_images_across_clusters(cluster_list, namespace_list)

    if dg_email:
        await send_email_with_results(result, dg_email)

    return result



from utils.ocp_auth import get_dyn_client_from_url
from utils.namespace_utils import is_non_prod_namespace
from services.aqua_service import get_aqua_token, get_existing_scan_report
import asyncio
import os

async def get_images_across_clusters(cluster_urls, input_namespaces=None):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    final_ns_map = {}

    # Step 1: Resolve namespaces per cluster
    for cluster_url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(cluster_url)

            if input_namespaces:
                ns_input = input_namespaces
            else:
                v1_ns = dyn_client.resources.get(api_version="v1", kind="Namespace")
                all_ns_raw = v1_ns.get().items
                ns_input = [ns.metadata.name for ns in all_ns_raw]

            non_prod_ns = []
            for ns in ns_input:
                if await is_non_prod_namespace(dyn_client, ns):
                    non_prod_ns.append(ns)

            if not non_prod_ns:
                raise Exception(f"No non-prod namespaces found in cluster {cluster_url}")

            final_ns_map[cluster_url] = non_prod_ns

        except Exception as e:
            skipped_images.append({
                "image": f"Cluster: {cluster_url}",
                "error": str(e)
            })

    # Step 2: Loop through each valid cluster+namespace to collect images
    for url, namespaces in final_ns_map.items():
        dyn_client = get_dyn_client_from_url(url)

        for ns in namespaces:
            ns_data = get_images_by_namespace(dyn_client, ns)  # already filtering deploy/dc/pods
            for image in ns_data["all_images"]:
                all_images.add(image)
                if image not in image_usage_map:
                    image_usage_map[image] = ns_data["image_usage"].get(image, {})
                else:
                    for key in ["Pods", "Deployments", "DeploymentConfigs"]:
                        image_usage_map[image].setdefault(key, [])
                        image_usage_map[image][key].extend(
                            ns_data["image_usage"].get(image, {}).get(key, [])
                        )

    # Step 3: Aqua token + reports
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Step 4: Parse vulnerabilities
    vulnerable_images = []
    image_fixes = {}
    image_usage = {}

    for image, report in image_report_map.items():
        if not report or "error" in report:
            skipped_images.append({
                "image": image,
                "error": report.get("error", "unknown error")
            })
            continue

        fixed_cves = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                fixed_cves.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if fixed_cves:
            vulnerable_images.append(image)
            image_fixes[image] = fixed_cves
            image_usage[image] = image_usage_map.get(image, {})

    return {
        "vulnerable_images": vulnerable_images,
        "image_fixes": image_fixes,
        "image_usage": image_usage,
        "skipped_images": skipped_images
    }



for url, namespaces in final_ns_map.items():
    dyn_client = get_dyn_client_from_url(url)

    for ns in namespaces:
        ns_data = get_images_by_namespace(dyn_client, ns)  # returns all_images + image_usage

        for image in ns_data["all_images"]:
            all_images.add(image)

            if image not in image_usage_map:
                image_usage_map[image] = []

            image_usage_map[image].append({
                "cluster": url,
                "namespace": ns,
                "resources": ns_data["image_usage"].get(image, {
                    "Pods": [],
                    "Deployments": [],
                    "DeploymentConfigs": []
                })
            })


from typing import Optional
from fastapi import APIRouter, Query
from services.image_service import get_images_across_clusters
from services.email_service import send_email_with_results

router = APIRouter()

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com"),
    namespaces: Optional[str] = Query(
        None, description="Comma-separated namespaces (optional). If not given, will scan all non-prod namespaces."
    ),
    dg_email: Optional[str] = Query(
        None, description="Optional: DG email to send vulnerability report"
    )
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",")] if namespaces else None

    result = await get_images_across_clusters(cluster_list, namespace_list)

    if dg_email:
        await send_email_with_results(result, dg_email)

    return result



import os
import asyncio
from utils.ocp_auth import get_dyn_client_from_url
from utils.namespace_utils import is_non_prod_namespace
from services.namespace_service import get_images_by_namespace
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls: list[str], namespace_list: list[str] = None):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    final_ns_map = {}  # {cluster_url: [non-prod namespaces]}

    # Step 1: Resolve and filter namespaces per cluster
    for cluster_url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(cluster_url)

            if namespace_list:
                input_ns = namespace_list
            else:
                ns_api = dyn_client.resources.get(api_version="v1", kind="Namespace")
                input_ns = [ns.metadata.name for ns in ns_api.get().items]

            non_prod_ns = []
            for ns in input_ns:
                try:
                    if is_non_prod_namespace(dyn_client, ns):
                        non_prod_ns.append(ns)
                    else:
                        skipped_images.append({
                            "image": f"ns:{ns}",
                            "error": f"Skipped prod namespace in {cluster_url}"
                        })
                except Exception as e:
                    skipped_images.append({
                        "image": f"ns:{ns}",
                        "error": f"Namespace validation failed in {cluster_url}: {str(e)}"
                    })

            if not non_prod_ns:
                skipped_images.append({
                    "image": f"cluster:{cluster_url}",
                    "error": "No non-prod namespaces found or accessible"
                })
                continue

            final_ns_map[cluster_url] = non_prod_ns

        except Exception as e:
            skipped_images.append({
                "image": f"cluster:{cluster_url}",
                "error": f"Failed to connect: {str(e)}"
            })

    # Step 2: Loop through valid clusters/namespaces to gather images
    for cluster_url, ns_list in final_ns_map.items():
        dyn_client = get_dyn_client_from_url(cluster_url)

        for ns in ns_list:
            try:
                ns_data = get_images_by_namespace(dyn_client, ns)

                for image in ns_data["all_images"]:
                    all_images.add(image)
                    if image not in image_usage_map:
                        image_usage_map[image] = []

                    image_usage_map[image].append({
                        "cluster": cluster_url,
                        "namespace": ns,
                        "resources": ns_data["image_usage"].get(image, {
                            "Pods": [],
                            "Deployments": [],
                            "DeploymentConfigs": []
                        })
                    })

            except Exception as e:
                skipped_images.append({
                    "image": f"cluster:{cluster_url}/ns:{ns}",
                    "error": f"Failed to get image usage: {str(e)}"
                })

    # Step 3: Get Aqua token
    token = await get_aqua_token(os.getenv("AQUA_USERNAME"), os.getenv("AQUA_PASSWORD"))

    # Step 4: Get existing reports
    scan_tasks = [get_existing_scan_report(image, token) for image in all_images]
    reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, reports))

    # Step 5: Analyze vulnerability and build result
    vulnerable_images = []
    image_fixes = {}

    for image, report in image_report_map.items():
        if not report or "error" in report or report.get("scan_error"):
            skipped_images.append({
                "image": image,
                "error": report.get("error") or report.get("scan_error", "Unknown scan issue")
            })
            continue

        cve_fixes = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                cve_fixes.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if cve_fixes:
            vulnerable_images.append(image)
            image_fixes[image] = cve_fixes

    return {
        "vulnerable_images": vulnerable_images,
        "image_fixes": image_fixes,
        "image_usage": image_usage_map,
        "skipped_images": skipped_images
    }


import re
from urllib.parse import urlparse
import httpx

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

def rewrite_image_url_for_aqua(image: str) -> str:
    """
    Rewrite OpenShift image URL to Aqua scan report-compatible path.
    Valid only for images starting with 'registry-nonprod.sdi.'
    Strips out any '@sha256:...' parts and converts to:
    registry/registry-nonprod/image/{image_path}/scan_result
    """
    if not image.startswith("registry-nonprod.sdi."):
        return None

    # Remove @sha if present
    image = re.sub(r'@sha256:[a-zA-Z0-9]+', '', image)

    parts = image.split('/')
    if len(parts) < 3:
        return None

    registry = parts[0].split('.')[0]  # 'registry-nonprod'
    path = '/'.join(parts[1:])

    return f"registry/{registry}/image/{path}/scan_result"

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    aqua_image_path = rewrite_image_url_for_aqua(image)

    if not aqua_image_path:
        return {"image": image, "error": "Image not eligible for scan (skipped)"}

    image_url = f"{AQUA_SCAN_URL}/{aqua_image_path}"

    async with httpx.AsyncClient(verify=False, timeout=20) as client:
        try:
            response = await client.get(image_url, headers=headers)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPStatusError as e:
            return {"image": image, "error": str(e)}
        except Exception as e:
            return {"image": image, "error": str(e)}


************** email ********************************

# services/email_service.py

import json
import ssl
import smtplib
from email.message import EmailMessage
from typing import Dict

FROM_EMAIL = "noreply@example.com"
SMTP_SERVER = "smtp.example.com"
SMTP_PORT = 587
SMTP_USERNAME = "your-username"
SMTP_PASSWORD = "your-password"

async def send_email_with_results(
    result: Dict,
    to_email: str,
    subject: str,
    html_content: str,
    json_filename: str = "report.json"
):
    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = FROM_EMAIL
    message["To"] = to_email

    # Plaintext fallback
    message.set_content("Please find the attached report.")

    # HTML content (passed in by the caller)
    message.add_alternative(html_content, subtype="html")

    # JSON attachment
    json_data = json.dumps(result, indent=2)
    message.add_attachment(
        json_data.encode("utf-8"),
        maintype="application",
        subtype="json",
        filename=json_filename
    )

    try:
        context = ssl.create_default_context()
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.send_message(message)
        print(f"✅ Email sent to {to_email}")
    except Exception as e:
        print(f"❌ Failed to send email to {to_email}; {e}")


from services.email_service import send_email_with_results
from services.email_service import build_html_report as build_get_html

html_content = build_get_html(result)
await send_email_with_results(
    result=result,
    to_email=email_to,
    subject="Vulnerability Scan Report",
    html_content=html_content,
    json_filename="vulnerability_report.json"
)


from services.email_service import send_email_with_results
from utils.formatters import build_html_report_from_delete  # specific to delete

html_content = build_html_report_from_delete(result)
await send_email_with_results(
    result=result,
    to_email=email_to,
    subject="Image Deletion Report",
    html_content=html_content,
    json_filename="deleted_images.json"
)

def build_html_report(data: dict, title: str = "OpenShift Report") -> str:
    def format_table(name, rows, headers):
        if not rows:
            return f"<h3>{name}</h3><p>No records found.</p>"
        table = f"<h3>{name}</h3><table border='1'><tr>{''.join(f'<th>{h}</th>' for h in headers)}</tr>"
        for row in rows:
            table += "<tr>" + "".join(f"<td>{row.get(h, '')}</td>" for h in headers) + "</tr>"
        table += "</table>"
        return table

    html = f"<html><body><h2>{title}</h2>"
    html += format_table("Stale Images", [{"Image": img} for img in data.get("stale_images", [])], ["Image"])
    html += format_table("Matched Pods", data.get("matched_pods", []), ["namespace", "pod_name", "image"])
    html += format_table("Matched Deployments", data.get("matched_deployments", []), ["namespace", "deployment_name", "image"])
    html += f"<p><b>Message:</b> {data.get('message', '')}</p>"
    html += "</body></html>"
    return html


