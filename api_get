from fastapi import FastAPI, Query
from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

app = FastAPI()

# Map your OpenShift cluster names to kubeconfig file paths
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

@app.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of OpenShift cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


from fastapi import APIRouter, Query
from typing import List
from services.image_service import get_cluster_images

router = APIRouter()

@router.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    return get_cluster_images(cluster_names, namespaces)

-----------------------------------

from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

# Update this with your actual cluster name to kubeconfig file path
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return dynamic.DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

def get_cluster_images(cluster_names: List[str], namespaces: List[str]) -> Dict:
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response

----------------------**************** ecluding build and deploy pods *************--------------------------------

import re

exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

...

if exclude_pattern.match(pod_name):
    continue


import re

def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # --- Pods ---
    try:
        # Compile a regex to match pod names like: myapp-1-build, app-deploy-abc, etc.
        exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name

            if exclude_pattern.match(pod_name):
                continue  # Skip build/deploy pods

            for container in pod.spec.containers:
                record_usage(container.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    # return result after all processing
    result["all_images"] = sorted(result["all_images"])
    return result

---------- ******* scan **********-------------------------


from fastapi import APIRouter, Query
from services.image_service import get_images_across_clusters

router = APIRouter()

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com", description="Comma-separated OpenShift cluster URLs"),
    namespaces: str = Query("default", description="Comma-separated namespaces")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    return await get_images_across_clusters(cluster_list, namespace_list)

*******************************************************************

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    response = {}
    all_images = set()

    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                all_images.update(ns_data["all_images"])
                cluster_data[ns] = ns_data

            response[url] = cluster_data
        except Exception as e:
            response[url] = {"error": str(e)}

    # Get Aqua token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Fetch reports in parallel
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Analyze reports and build final structure
    vulnerable_images_with_fixes = []

    for cluster_data in response.values():
        for ns_data in cluster_data.values():
            image_usage = ns_data.get("image_usage", {})
            ns_data["vulnerabilities"] = {}

            for image in ns_data["all_images"]:
                report = image_report_map.get(image, {})
                ns_data["vulnerabilities"][image] = report

                if not report or "error" in report:
                    continue

                fixed_cves = []
                for cve in report.get("cves", []):
                    fix = cve.get("fix_version")
                    if fix:
                        fixed_cves.append({
                            "name": cve.get("name"),
                            "severity": cve.get("severity"),
                            "fix_version": fix,
                            "file": cve.get("file"),
                            "url": cve.get("url")
                        })

                if fixed_cves:
                    vulnerable_images_with_fixes.append({
                        "image": image,
                        "used_by": image_usage.get(image, {}),
                        "vulnerabilities": fixed_cves
                    })

    response["vulnerable_images_with_fixes"] = vulnerable_images_with_fixes
    return response


def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for deploy in deployments.items:
            for c in deploy.spec.template.spec.containers:
                record_usage(c.image, "Deployments", deploy.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name
            if exclude_pattern.match(pod_name):
                continue
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result
**********************************************************************************

import httpx

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    image_url = f"{AQUA_SCAN_URL}/{image.lstrip('/')}"
    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}


for cluster_data in response.values():
    if not isinstance(cluster_data, dict):
        continue
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue
        image_usage = ns_data.get("image_usage", {})


print("DEBUG ns_data =", ns_data, type(ns_data))


# Analyze reports and build final structure
vulnerable_images_with_fixes = []

for cluster_data in response.values():
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue

        image_usage = ns_data.get("image_usage", {})
        ns_data["vulnerabilities"] = {}

        for image in ns_data["all_images"]:
            report = image_report_map.get(image, {})
            ns_data["vulnerabilities"][image] = report

            if not report or "error" in report:
                continue

            fixed_cves = []
            for cve in report.get("cves", []):
                fix = cve.get("fix_version")
                if fix:
                    fixed_cves.append({
                        "name": cve.get("name"),
                        "severity": cve.get("severity"),
                        "fix_version": fix,
                        "file": cve.get("file"),
                        "url": cve.get("url")
                    })

            if fixed_cves:
                vulnerable_images_with_fixes.append({
                    "image": image,
                    "used_by": image_usage.get(image, {}),
                    "vulnerabilities": fixed_cves
                })

import httpx
from urllib.parse import urljoin

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

def rewrite_image_url_for_aqua(image: str) -> str:
    """
    Converts OpenShift image URL into Aqua-compatible path.
    From: registry-nonprod.sdi.crp.bnk.com/73717/imagename:tag
    To:   registry-nonprod/73717/imagename:tag
    """
    parts = image.split('/')
    if len(parts) >= 3:
        registry_full = parts[0]
        registry = registry_full.split('.')[0]  # only 'registry-nonprod'
        path = '/'.join(parts[1:])
        return f"{registry}/{path}"
    return image  # fallback as-is

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    aqua_image_path = rewrite_image_url_for_aqua(image)
    image_url = urljoin(AQUA_SCAN_URL + "/", aqua_image_path)

    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}

