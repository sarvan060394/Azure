from fastapi import FastAPI, Query
from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

app = FastAPI()

# Map your OpenShift cluster names to kubeconfig file paths
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

@app.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of OpenShift cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response


$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$


from fastapi import APIRouter, Query
from typing import List
from services.image_service import get_cluster_images

router = APIRouter()

@router.get("/get-images")
def get_images(
    cluster_names: List[str] = Query(..., description="List of cluster names"),
    namespaces: List[str] = Query(..., description="List of namespaces")
):
    return get_cluster_images(cluster_names, namespaces)

-----------------------------------

from typing import List, Dict
from kubernetes import config, dynamic
from openshift.dynamic import DynamicClient

# Update this with your actual cluster name to kubeconfig file path
KUBECONFIG_MAP = {
    "prod": "/kubeconfigs/prod-kubeconfig",
    "dev": "/kubeconfigs/dev-kubeconfig"
}

def get_dyn_client(kubeconfig_path: str) -> DynamicClient:
    k8s_client = config.new_client_from_config(config_file=kubeconfig_path)
    return dynamic.DynamicClient(k8s_client)

def get_images_by_namespace(dyn_client: DynamicClient, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # Deployments
    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for dep in deployments.items:
            for c in dep.spec.template.spec.containers:
                record_usage(c.image, "Deployments", dep.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    # DeploymentConfigs
    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    # Pods
    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result

def get_cluster_images(cluster_names: List[str], namespaces: List[str]) -> Dict:
    response = {}

    for cluster_name in cluster_names:
        kubeconfig_path = KUBECONFIG_MAP.get(cluster_name)
        if not kubeconfig_path:
            response[cluster_name] = {"error": f"No kubeconfig found for cluster '{cluster_name}'"}
            continue

        try:
            dyn_client = get_dyn_client(kubeconfig_path)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                cluster_data[ns] = ns_data

            response[cluster_name] = cluster_data

        except Exception as e:
            response[cluster_name] = {"error": str(e)}

    return response

----------------------**************** ecluding build and deploy pods *************--------------------------------

import re

exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

...

if exclude_pattern.match(pod_name):
    continue


import re

def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    # --- Pods ---
    try:
        # Compile a regex to match pod names like: myapp-1-build, app-deploy-abc, etc.
        exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name

            if exclude_pattern.match(pod_name):
                continue  # Skip build/deploy pods

            for container in pod.spec.containers:
                record_usage(container.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    # return result after all processing
    result["all_images"] = sorted(result["all_images"])
    return result

---------- ******* scan **********-------------------------


from fastapi import APIRouter, Query
from services.image_service import get_images_across_clusters

router = APIRouter()

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com", description="Comma-separated OpenShift cluster URLs"),
    namespaces: str = Query("default", description="Comma-separated namespaces")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    return await get_images_across_clusters(cluster_list, namespace_list)

*******************************************************************

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    response = {}
    all_images = set()

    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)
            cluster_data = {}

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                all_images.update(ns_data["all_images"])
                cluster_data[ns] = ns_data

            response[url] = cluster_data
        except Exception as e:
            response[url] = {"error": str(e)}

    # Get Aqua token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Fetch reports in parallel
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Analyze reports and build final structure
    vulnerable_images_with_fixes = []

    for cluster_data in response.values():
        for ns_data in cluster_data.values():
            image_usage = ns_data.get("image_usage", {})
            ns_data["vulnerabilities"] = {}

            for image in ns_data["all_images"]:
                report = image_report_map.get(image, {})
                ns_data["vulnerabilities"][image] = report

                if not report or "error" in report:
                    continue

                fixed_cves = []
                for cve in report.get("cves", []):
                    fix = cve.get("fix_version")
                    if fix:
                        fixed_cves.append({
                            "name": cve.get("name"),
                            "severity": cve.get("severity"),
                            "fix_version": fix,
                            "file": cve.get("file"),
                            "url": cve.get("url")
                        })

                if fixed_cves:
                    vulnerable_images_with_fixes.append({
                        "image": image,
                        "used_by": image_usage.get(image, {}),
                        "vulnerabilities": fixed_cves
                    })

    response["vulnerable_images_with_fixes"] = vulnerable_images_with_fixes
    return response


def get_images_by_namespace(dyn_client, namespace: str) -> dict:
    result = {
        "all_images": set(),
        "image_usage": {}
    }

    def record_usage(image: str, kind: str, name: str):
        result["all_images"].add(image)
        usage = result["image_usage"].setdefault(image, {
            "Deployments": [],
            "DeploymentConfigs": [],
            "Pods": []
        })
        usage[kind].append(name)

    exclude_pattern = re.compile(r".*(build|deploy).*", re.IGNORECASE)

    try:
        dcs = dyn_client.resources.get(api_version="apps.openshift.io/v1", kind="DeploymentConfig").get(namespace=namespace)
        for dc in dcs.items:
            for c in dc.spec.template.spec.containers:
                record_usage(c.image, "DeploymentConfigs", dc.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching DeploymentConfigs: {e}")

    try:
        deployments = dyn_client.resources.get(api_version="apps/v1", kind="Deployment").get(namespace=namespace)
        for deploy in deployments.items:
            for c in deploy.spec.template.spec.containers:
                record_usage(c.image, "Deployments", deploy.metadata.name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Deployments: {e}")

    try:
        pods = dyn_client.resources.get(api_version="v1", kind="Pod").get(namespace=namespace)
        for pod in pods.items:
            pod_name = pod.metadata.name
            if exclude_pattern.match(pod_name):
                continue
            for c in pod.spec.containers:
                record_usage(c.image, "Pods", pod_name)
    except Exception as e:
        print(f"[{namespace}] Error fetching Pods: {e}")

    result["all_images"] = sorted(result["all_images"])
    return result
**********************************************************************************

import httpx

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    image_url = f"{AQUA_SCAN_URL}/{image.lstrip('/')}"
    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}


for cluster_data in response.values():
    if not isinstance(cluster_data, dict):
        continue
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue
        image_usage = ns_data.get("image_usage", {})


print("DEBUG ns_data =", ns_data, type(ns_data))


# Analyze reports and build final structure
vulnerable_images_with_fixes = []

for cluster_data in response.values():
    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue

        image_usage = ns_data.get("image_usage", {})
        ns_data["vulnerabilities"] = {}

        for image in ns_data["all_images"]:
            report = image_report_map.get(image, {})
            ns_data["vulnerabilities"][image] = report

            if not report or "error" in report:
                continue

            fixed_cves = []
            for cve in report.get("cves", []):
                fix = cve.get("fix_version")
                if fix:
                    fixed_cves.append({
                        "name": cve.get("name"),
                        "severity": cve.get("severity"),
                        "fix_version": fix,
                        "file": cve.get("file"),
                        "url": cve.get("url")
                    })

            if fixed_cves:
                vulnerable_images_with_fixes.append({
                    "image": image,
                    "used_by": image_usage.get(image, {}),
                    "vulnerabilities": fixed_cves
                })

import httpx
from urllib.parse import urljoin

AQUA_BASE_URL = "https://gis-container-scan.bankofamerica.com/api/v1"
AQUA_LOGIN_URL = f"{AQUA_BASE_URL}/login"
AQUA_SCAN_URL = f"{AQUA_BASE_URL}/scanner/registry"

async def get_aqua_token(username: str, password: str) -> str:
    async with httpx.AsyncClient() as client:
        response = await client.post(
            AQUA_LOGIN_URL,
            json={"id": username, "password": password},
            headers={"Content-Type": "application/json"}
        )
        response.raise_for_status()
        return response.json().get("token")

def rewrite_image_url_for_aqua(image: str) -> str:
    """
    Converts OpenShift image URL into Aqua-compatible path.
    From: registry-nonprod.sdi.crp.bnk.com/73717/imagename:tag
    To:   registry-nonprod/73717/imagename:tag
    """
    parts = image.split('/')
    if len(parts) >= 3:
        registry_full = parts[0]
        registry = registry_full.split('.')[0]  # only 'registry-nonprod'
        path = '/'.join(parts[1:])
        return f"{registry}/{path}"
    return image  # fallback as-is

async def get_existing_scan_report(image: str, token: str) -> dict:
    headers = {"Authorization": f"Bearer {token}"}
    aqua_image_path = rewrite_image_url_for_aqua(image)
    image_url = urljoin(AQUA_SCAN_URL + "/", aqua_image_path)

    async with httpx.AsyncClient() as client:
        response = await client.get(image_url, headers=headers)
        if response.status_code == 200:
            result = response.json()
            return result if result.get("scan_error", "") == "" else {"error": result.get("scan_error")}
        return {"error": f"Failed to fetch report for {image}"}

vulnerable_images = []
vulnerable_image_fixes = {}
resource_usage = {}

for cluster_data in response.values():
    if not isinstance(cluster_data, dict):
        continue

    for ns_data in cluster_data.values():
        if not isinstance(ns_data, dict):
            continue

        image_usage = ns_data.get("image_usage", {})
        ns_data["vulnerabilities"] = {}

        for image in ns_data["all_images"]:
            report = image_report_map.get(image, {})
            ns_data["vulnerabilities"][image] = report

            if not report or "error" in report:
                continue

            fixed_cves = []
            for cve in report.get("cves", []):
                fix = cve.get("fix_version")
                if fix:
                    fixed_cves.append({
                        "name": cve.get("name"),
                        "severity": cve.get("severity"),
                        "fix_version": fix,
                        "file": cve.get("file"),
                        "url": cve.get("url")
                    })

            if fixed_cves:
                vulnerable_images.append(image)
                vulnerable_image_fixes[image] = fixed_cves
                resource_usage[image] = image_usage.get(image, {})

# Final structured response to user
return {
    "vulnerable_images": sorted(set(vulnerable_images)),
    "vulnerable_image_fixes": vulnerable_image_fixes,
    "resource_usage": resource_usage
}

*****************************************************

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    # Step 1: Collect all images and their usage across clusters and namespaces
    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                for image in ns_data["all_images"]:
                    all_images.add(image)
                    if image not in image_usage_map:
                        image_usage_map[image] = ns_data["image_usage"].get(image, {})
                    else:
                        # Merge usage if already exists
                        for key in ["Pods", "Deployments", "DeploymentConfigs"]:
                            image_usage_map[image].setdefault(key, [])
                            image_usage_map[image][key].extend(ns_data["image_usage"].get(image, {}).get(key, []))

        except Exception as e:
            skipped_images.append({
                "image": f"Cluster: {url}",
                "error": str(e)
            })

    # Step 2: Get Aqua Token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Step 3: Fetch reports in parallel
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Step 4: Process vulnerabilities
    vulnerable_images = []

    for image, report in image_report_map.items():
        if not report or "error" in report:
            skipped_images.append({
                "image": image,
                "error": report.get("error", "unknown error")
            })
            continue

        fixed_cves = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                fixed_cves.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if fixed_cves:
            vulnerable_images.append({
                "image": image,
                "fixes": fixed_cves,
                "used_by": image_usage_map.get(image, {})
            })

    return {
        "vulnerable_images": vulnerable_images,
        "skipped_images": skipped_images
    }

import os
import asyncio
import re
from utils.ocp_auth import get_dyn_client_from_url
from services.aqua_service import get_aqua_token, get_existing_scan_report

async def get_images_across_clusters(cluster_urls, namespaces):
    all_images = set()
    image_usage_map = {}
    skipped_images = []

    # Step 1: Collect all images and usage
    for url in cluster_urls:
        try:
            dyn_client = get_dyn_client_from_url(url)

            for ns in namespaces:
                ns_data = get_images_by_namespace(dyn_client, ns)
                for image in ns_data["all_images"]:
                    all_images.add(image)
                    if image not in image_usage_map:
                        image_usage_map[image] = ns_data["image_usage"].get(image, {})
                    else:
                        for key in ["Pods", "Deployments", "DeploymentConfigs"]:
                            image_usage_map[image].setdefault(key, [])
                            image_usage_map[image][key].extend(
                                ns_data["image_usage"].get(image, {}).get(key, [])
                            )
        except Exception as e:
            skipped_images.append({
                "image": f"Cluster: {url}",
                "error": str(e)
            })

    # Step 2: Get Aqua Token
    aqua_username = os.getenv("AQUA_USERNAME")
    aqua_password = os.getenv("AQUA_PASSWORD")
    token = await get_aqua_token(aqua_username, aqua_password)

    # Step 3: Fetch Aqua scan reports
    scan_tasks = [get_existing_scan_report(img, token) for img in all_images]
    scan_reports = await asyncio.gather(*scan_tasks)
    image_report_map = dict(zip(all_images, scan_reports))

    # Step 4: Build final return values
    vulnerable_images = []
    image_fixes = {}
    image_usage = {}
    
    for image, report in image_report_map.items():
        if not report or "error" in report:
            skipped_images.append({
                "image": image,
                "error": report.get("error", "unknown error")
            })
            continue

        fixed_cves = []
        for cve in report.get("cves", []):
            if cve.get("fix_version"):
                fixed_cves.append({
                    "name": cve.get("name"),
                    "severity": cve.get("severity"),
                    "fix_version": cve.get("fix_version"),
                    "file": cve.get("file"),
                    "url": cve.get("url")
                })

        if fixed_cves:
            vulnerable_images.append(image)
            image_fixes[image] = fixed_cves
            image_usage[image] = image_usage_map.get(image, {})

    return {
        "vulnerable_images": vulnerable_images,
        "image_fixes": image_fixes,
        "image_usage": image_usage,
        "skipped_images": skipped_images
    }



---

@router.get("/get-images")
async def get_images(
    openshift_cluster_urls: str = Query("https://api.ocp-dev.com"),
    namespaces: str = Query("default"),
    dg_email: str = Query(..., description="Distribution group email to send results")
):
    cluster_list = [url.strip() for url in openshift_cluster_urls.split(",") if url.strip()]
    namespace_list = [ns.strip() for ns in namespaces.split(",") if ns.strip()]
    result = await get_images_across_clusters(cluster_list, namespace_list)

    # Send email with result
    await send_email_with_results(result, dg_email)

    return result
import smtplib
import json
from email.message import EmailMessage
import ssl
import os

SMTP_SERVER = os.getenv("SMTP_SERVER", "smtp.yourorg.com")
SMTP_PORT = int(os.getenv("SMTP_PORT", "587"))
SMTP_USERNAME = os.getenv("SMTP_USERNAME")
SMTP_PASSWORD = os.getenv("SMTP_PASSWORD")
FROM_EMAIL = os.getenv("FROM_EMAIL", SMTP_USERNAME)

async def send_email_with_results(result: dict, to_email: str):
    subject = "OpenShift Vulnerability Report"
    message = EmailMessage()
    message["Subject"] = subject
    message["From"] = FROM_EMAIL
    message["To"] = to_email

    # Pretty JSON string as body
    result_summary = json.dumps({
        "vulnerable_images": result.get("vulnerable_images", []),
        "image_fixes": result.get("image_fixes", {}),
        "image_usage": result.get("image_usage", {}),
        "skipped_images": result.get("skipped_images", [])
    }, indent=2)

    message.set_content(f"""✅ OpenShift Vulnerability Report

{result_summary}
""")

    # Attach full JSON as file too
    message.add_attachment(
        result_summary.encode("utf-8"),
        maintype="application",
        subtype="json",
        filename="vulnerability_report.json"
    )

    try:
        context = ssl.create_default_context()
        with smtplib.SMTP(SMTP_SERVER, SMTP_PORT) as server:
            server.starttls(context=context)
            server.login(SMTP_USERNAME, SMTP_PASSWORD)
            server.send_message(message)
            print(f"✅ Email sent to {to_email}")
    except Exception as e:
        print(f"❌ Failed to send email to {to_email}: {e}")


