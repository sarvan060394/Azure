h1. Managing Existing Venafi Certificates Using Cert Manager

h2. Overview
This document provides a step-by-step guide on how to manage an **already existing certificate** that was created in Venafi under a specific AIT policy tree using Cert Manager. This ensures seamless tracking, renewal, and usage of the certificate in Kubernetes.

---

h2. Steps to Manage Existing Certificate

h3. 1. Venafi Team Provides Client ID and Access Token

* The Venafi team needs to create a **Client ID** in the **Trust Protection Platform (TPP)**.
* They will provide the **Client ID** and **Access Token** required for authentication.

---

h3. 2. Create a Secret with the Access Token

* Store the access token in a Kubernetes secret to be used by Cert Manager.

*Example Command:*
```bash
kubectl create secret generic venafi-auth-secret \
  --from-literal=access-token=<VENAFI_ACCESS_TOKEN> \
  -n cert-manager
```
This secret will be referenced in the ClusterIssuer resource.

---

h3. 3. Create a Secret with the Generated Certificate

* Retrieve the existing certificate and key from Venafi.
* Create a Kubernetes Secret to store the certificate and key.

*Example Command:*
```bash
kubectl create secret tls my-venafi-cert-secret \
  --cert=/path/to/existing.crt \
  --key=/path/to/existing.key \
  -n my-namespace
```
This secret will be referenced in the Cert Manager **Certificate** object.

---

h3. 4. Create a ClusterIssuer Resource

* Define a **ClusterIssuer** to reference the Venafi authentication secret and specify the policy tree.

*Example YAML:*
```yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: venafi-cluster-issuer
spec:
  venafi:
    zone: "AIT/Policy/Tree/Path"
    tpp:
      url: "https://venafi-tpp-url"
      credentialsRef:
        name: venafi-auth-secret
```

---

h3. 5. Create a Certificate Object with That Secret Name

* Define a **Certificate** resource and reference the secret created above.
* Specify the correct **ClusterIssuer** that uses Venafi.

*Example YAML:*
```yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: my-venafi-cert
  namespace: my-namespace
spec:
  secretName: my-venafi-cert-secret
  issuerRef:
    name: venafi-cluster-issuer
    kind: ClusterIssuer
  duration: 90d
  renewBefore: 30d
```

---

h3. 6. Cert Manager Will Not Issue a Fresh Certificate If the Secret Exists

* If the **secret already exists**, Cert Manager will not request a new certificate until renewal criteria are met.
* To force a renewal, delete the secret manually:
```bash
kubectl delete secret my-venafi-cert-secret -n my-namespace
```
* Cert Manager will automatically request a new certificate upon secret deletion.

---

h3. 7. Ensuring the Right Expiry in the Certificate Object

* Use the `duration` field to define certificate validity (e.g., `90d`).
* Set `renewBefore` to control when renewal begins (e.g., `30d` before expiry).

**Monitoring Certificate Status:**
```bash
kubectl get certificate my-venafi-cert -n my-namespace
```

**Check Expiration and Renewal Details:**
```bash
kubectl describe certificate my-venafi-cert -n my-namespace
```

---

h2. Summary
| **Step** | **Action** |
|----------|-----------|
| 1. Obtain Credentials | Venafi team provides Client ID and Access Token. |
| 2. Create Access Token Secret | Store the access token in a Kubernetes secret. |
| 3. Create Certificate Secret | Store the existing certificate and key in a Kubernetes secret. |
| 4. Create ClusterIssuer | Reference the authentication secret and define the Venafi policy tree. |
| 5. Create Certificate Object | Reference the secret and configure the Venafi issuer. |
| 6. Renewal Logic | Cert Manager will not issue a new certificate if a valid secret exists. |
| 7. Expiry Configuration | Use `duration` and `renewBefore` to ensure timely renewal. |

By following these steps, you can effectively manage an **existing Venafi certificate** under the AIT policy tree, ensuring seamless integration with Cert Manager for tracking and renewal.

