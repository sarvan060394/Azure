Python api:
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import os
import shutil
import stat
import git

app = FastAPI()

# Hardcoded Bitbucket credentials
USERNAME = "your_username"
ACCESS_TOKEN = "your_bitbucket_app_password_or_token"

class CloneRequest(BaseModel):
    repo_url: str
    branch: str
    target_path: str

def force_remove_readonly(func, path, _):
    os.chmod(path, stat.S_IWRITE)
    func(path)

@app.post("/clone")
def clone_repo(req: CloneRequest):
    # Check if the target path already exists
    if os.path.exists(req.target_path):
        try:
            shutil.rmtree(req.target_path, onerror=force_remove_readonly)
        except Exception as e:
            raise HTTPException(status_code=500, detail=f"Failed to delete existing directory: {e}")

    # Build authenticated repo URL
    if "@" in req.repo_url:
        # already contains username/password (strip them)
        prefix, rest = req.repo_url.split("@", 1)
        req.repo_url = rest

    auth_url = req.repo_url.replace("https://", f"https://{USERNAME}:{ACCESS_TOKEN}@")

    try:
        git.Repo.clone_from(auth_url, req.target_path, branch=req.branch)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Git clone failed: {e}")

    return {"message": "Repository cloned successfully."}


********************************************************************************
MCP tool:

import requests

@mcp.tool(name="clone_template", description="Clone template code from Bitbucket using FastAPI")
def clone_template() -> dict:
    try:
        payload = {
            "repo_url": "https://bitbucket.mycompany.com/scm/project/repo.git",
            "branch": "develop",
            "target_path": "./cloned_template"
        }

        response = requests.post("http://localhost:8000/clone", json=payload)

        if response.status_code == 200:
            return {"result": response.json()["message"]}
        else:
            return {"error": response.text}
    except Exception as e:
        return {"error": str(e)}


(((((((((((((((((((((((((((((((((((((((((((((((((()))))))))))))))))))))))))))))))))))

import requests
from mcp import tool

@tool(
    name="clone_template",
    description="Clone template code from Bitbucket using FastAPI",
)
def clone_template(repo_url: str, branch: str, target_path: str) -> dict:
    try:
        payload = {
            "repo_url": repo_url,
            "branch": branch,
            "target_path": target_path
        }

        response = requests.post("http://localhost:8000/clone", json=payload)
        response.raise_for_status()

        return {"result": response.json()["message"]}
    except Exception as e:
        raise RuntimeError(f"Clone failed: {e}")

**************************** new one ***************************************************

import httpx
from mcp import tool

@tool(
    name="clone_template",
    description="Clone template code from Bitbucket using FastAPI",
)
async def clone_template(repo_url: str, branch: str, target_path: str) -> dict:
    try:
        payload = {
            "repo_url": repo_url,
            "branch": branch,
            "target_path": target_path
        }

        async with httpx.AsyncClient(timeout=30.0) as client:
            response = await client.post("http://localhost:8000/clone", json=payload)
            response.raise_for_status()

        return {"result": response.json()["message"]}
    except Exception as e:
        raise RuntimeError(f"Clone failed: {e}")


Python App: *****************

from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
import os
import shutil
import stat
import git
import asyncio
from fastapi.concurrency import run_in_threadpool

app = FastAPI()

# Credentials â€“ ideally read from env
USERNAME = os.getenv("BITBUCKET_USERNAME", "your_username")
ACCESS_TOKEN = os.getenv("BITBUCKET_TOKEN", "your_bitbucket_token")

class CloneRequest(BaseModel):
    repo_url: str
    branch: str
    target_path: str

def force_remove_readonly(func, path, _):
    os.chmod(path, stat.S_IWRITE)
    func(path)

def _clone_repo(repo_url: str, branch: str, target_path: str):
    if os.path.exists(target_path):
        shutil.rmtree(target_path, onerror=force_remove_readonly)

    if "@" in repo_url:
        # Clean existing creds in URL if any
        _, rest = repo_url.split("@", 1)
        repo_url = rest

    # Add credentials for authenticated access
    auth_url = repo_url.replace("https://", f"https://{USERNAME}:{ACCESS_TOKEN}@")

    # Clone the repo
    git.Repo.clone_from(auth_url, target_path, branch=branch)

@app.post("/clone")
async def clone_repo(req: CloneRequest):
    try:
        await run_in_threadpool(_clone_repo, req.repo_url, req.branch, req.target_path)
        return {"message": "Repository cloned successfully."}
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Git clone failed: {e}")


